{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { h, ref, computed, watch, nextTick, onBeforeUnmount, onActivated, onDeactivated, getCurrentInstance, provide } from 'vue';\nimport QIcon from '../icon/QIcon.js';\nimport QResizeObserver from '../resize-observer/QResizeObserver.js';\nimport useTick from '../../composables/private/use-tick.js';\nimport useTimeout from '../../composables/private/use-timeout.js';\nimport { createComponent } from '../../utils/private/create.js';\nimport { noop } from '../../utils/event.js';\nimport { hSlot } from '../../utils/private/render.js';\nimport { tabsKey } from '../../utils/private/symbols.js';\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js';\n\nfunction getIndicatorClass(color, top, vertical) {\n  const pos = vertical === true ? ['left', 'right'] : ['top', 'bottom'];\n  return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ''}`;\n}\n\nconst alignValues = ['left', 'center', 'right', 'justify'];\n\nconst emptyFn = () => {};\n\nexport default createComponent({\n  name: 'QTabs',\n  props: {\n    modelValue: [Number, String],\n    align: {\n      type: String,\n      default: 'center',\n      validator: v => alignValues.includes(v)\n    },\n    breakpoint: {\n      type: [String, Number],\n      default: 600\n    },\n    vertical: Boolean,\n    shrink: Boolean,\n    stretch: Boolean,\n    activeClass: String,\n    activeColor: String,\n    activeBgColor: String,\n    indicatorColor: String,\n    leftIcon: String,\n    rightIcon: String,\n    outsideArrows: Boolean,\n    mobileArrows: Boolean,\n    switchIndicator: Boolean,\n    narrowIndicator: Boolean,\n    inlineLabel: Boolean,\n    noCaps: Boolean,\n    dense: Boolean,\n    contentClass: String,\n    'onUpdate:modelValue': [Function, Array]\n  },\n\n  setup(props, {\n    slots,\n    emit\n  }) {\n    const vm = getCurrentInstance();\n    const {\n      proxy: {\n        $q\n      }\n    } = vm;\n    const {\n      registerTick: registerScrollTick\n    } = useTick();\n    const {\n      registerTimeout: registerFocusTimeout,\n      removeTimeout: removeFocusTimeout\n    } = useTimeout();\n    const {\n      registerTimeout\n    } = useTimeout();\n    const rootRef = ref(null);\n    const contentRef = ref(null);\n    const currentModel = ref(props.modelValue);\n    const scrollable = ref(false);\n    const leftArrow = ref(true);\n    const rightArrow = ref(false);\n    const justify = ref(false);\n    const arrowsEnabled = computed(() => $q.platform.is.desktop === true || props.mobileArrows === true);\n    const tabList = [];\n    const hasFocus = ref(false);\n    let localFromRoute = false,\n        animateTimer,\n        scrollTimer,\n        unwatchRoute;\n    let localUpdateArrows = arrowsEnabled.value === true ? updateArrowsFn : noop;\n    const tabProps = computed(() => ({\n      activeClass: props.activeClass,\n      activeColor: props.activeColor,\n      activeBgColor: props.activeBgColor,\n      indicatorClass: getIndicatorClass(props.indicatorColor, props.switchIndicator, props.vertical),\n      narrowIndicator: props.narrowIndicator,\n      inlineLabel: props.inlineLabel,\n      noCaps: props.noCaps\n    }));\n    const alignClass = computed(() => {\n      const align = scrollable.value === true ? 'left' : justify.value === true ? 'justify' : props.align;\n      return `q-tabs__content--align-${align}`;\n    });\n    const classes = computed(() => 'q-tabs row no-wrap items-center' + ` q-tabs--${scrollable.value === true ? '' : 'not-'}scrollable` + ` q-tabs--${props.vertical === true ? 'vertical' : 'horizontal'}` + ` q-tabs__arrows--${arrowsEnabled.value === true && props.outsideArrows === true ? 'outside' : 'inside'}` + (props.dense === true ? ' q-tabs--dense' : '') + (props.shrink === true ? ' col-shrink' : '') + (props.stretch === true ? ' self-stretch' : ''));\n    const innerClass = computed(() => 'q-tabs__content row no-wrap items-center self-stretch hide-scrollbar relative-position ' + alignClass.value + (props.contentClass !== void 0 ? ` ${props.contentClass}` : '') + ($q.platform.is.mobile === true ? ' scroll' : ''));\n    const domProps = computed(() => props.vertical === true ? {\n      container: 'height',\n      content: 'offsetHeight',\n      scroll: 'scrollHeight'\n    } : {\n      container: 'width',\n      content: 'offsetWidth',\n      scroll: 'scrollWidth'\n    });\n    const isRTL = computed(() => props.vertical !== true && $q.lang.rtl === true);\n    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true);\n    watch(isRTL, localUpdateArrows);\n    watch(() => props.modelValue, name => {\n      updateModel({\n        name,\n        setCurrent: true,\n        skipEmit: true\n      });\n    });\n    watch(() => props.outsideArrows, () => {\n      nextTick(recalculateScroll());\n    });\n    watch(arrowsEnabled, v => {\n      localUpdateArrows = v === true ? updateArrowsFn : noop;\n      nextTick(recalculateScroll());\n    });\n\n    function updateModel({\n      name,\n      setCurrent,\n      skipEmit,\n      fromRoute\n    }) {\n      if (currentModel.value !== name) {\n        skipEmit !== true && emit('update:modelValue', name);\n\n        if (setCurrent === true || props['onUpdate:modelValue'] === void 0) {\n          animate(currentModel.value, name);\n          currentModel.value = name;\n        }\n      }\n\n      if (fromRoute !== void 0) {\n        localFromRoute = fromRoute;\n      }\n    }\n\n    function recalculateScroll() {\n      registerScrollTick(() => {\n        if (vm.isDeactivated !== true && vm.isUnmounted !== true) {\n          updateContainer({\n            width: rootRef.value.offsetWidth,\n            height: rootRef.value.offsetHeight\n          });\n        }\n      });\n    }\n\n    function updateContainer(domSize) {\n      // it can be called faster than component being initialized\n      // so we need to protect against that case\n      // (one example of such case is the docs release notes page)\n      if (domProps.value === void 0 || contentRef.value === null) {\n        return;\n      }\n\n      const size = domSize[domProps.value.container],\n            scrollSize = Math.min(contentRef.value[domProps.value.scroll], Array.prototype.reduce.call(contentRef.value.children, (acc, el) => acc + (el[domProps.value.content] || 0), 0)),\n            scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1\n\n      if (scrollable.value !== scroll) {\n        scrollable.value = scroll;\n      } // Arrows need to be updated even if the scroll status was already true\n\n\n      scroll === true && nextTick(localUpdateArrows);\n      const localJustify = size < parseInt(props.breakpoint, 10);\n\n      if (justify.value !== localJustify) {\n        justify.value = localJustify;\n      }\n    }\n\n    function animate(oldName, newName) {\n      const oldTab = oldName !== void 0 && oldName !== null && oldName !== '' ? tabList.find(tab => tab.name.value === oldName) : null,\n            newTab = newName !== void 0 && newName !== null && newName !== '' ? tabList.find(tab => tab.name.value === newName) : null;\n\n      if (oldTab && newTab) {\n        const oldEl = oldTab.tabIndicatorRef.value,\n              newEl = newTab.tabIndicatorRef.value;\n        clearTimeout(animateTimer);\n        oldEl.style.transition = 'none';\n        oldEl.style.transform = 'none';\n        newEl.style.transition = 'none';\n        newEl.style.transform = 'none';\n        const oldPos = oldEl.getBoundingClientRect(),\n              newPos = newEl.getBoundingClientRect();\n        newEl.style.transform = props.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`; // allow scope updates to kick in (QRouteTab needs more time)\n\n        nextTick(() => {\n          animateTimer = setTimeout(() => {\n            newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';\n            newEl.style.transform = 'none';\n          }, 70);\n        });\n      }\n\n      if (newTab && scrollable.value === true) {\n        scrollToTabEl(newTab.rootRef.value);\n      }\n    }\n\n    function scrollToTabEl(el) {\n      const {\n        left,\n        width,\n        top,\n        height\n      } = contentRef.value.getBoundingClientRect(),\n            newPos = el.getBoundingClientRect();\n      let offset = props.vertical === true ? newPos.top - top : newPos.left - left;\n\n      if (offset < 0) {\n        contentRef.value[props.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.floor(offset);\n        localUpdateArrows();\n        return;\n      }\n\n      offset += props.vertical === true ? newPos.height - height : newPos.width - width;\n\n      if (offset > 0) {\n        contentRef.value[props.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.ceil(offset);\n        localUpdateArrows();\n      }\n    }\n\n    function updateArrowsFn() {\n      const content = contentRef.value;\n\n      if (content !== null) {\n        const rect = content.getBoundingClientRect(),\n              pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft);\n\n        if (isRTL.value === true) {\n          leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1;\n          rightArrow.value = pos > 0;\n        } else {\n          leftArrow.value = pos > 0;\n          rightArrow.value = props.vertical === true ? Math.ceil(pos + rect.height) < content.scrollHeight : Math.ceil(pos + rect.width) < content.scrollWidth;\n        }\n      }\n    }\n\n    function animScrollTo(value) {\n      stopAnimScroll();\n      scrollTowards(value);\n      scrollTimer = setInterval(() => {\n        if (scrollTowards(value) === true) {\n          stopAnimScroll();\n        }\n      }, 5);\n    }\n\n    function scrollToStart() {\n      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);\n    }\n\n    function scrollToEnd() {\n      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);\n    }\n\n    function stopAnimScroll() {\n      clearInterval(scrollTimer);\n    }\n\n    function onKbdNavigate(keyCode, fromEl) {\n      const tabs = Array.prototype.filter.call(contentRef.value.children, el => el === fromEl || el.matches && el.matches('.q-tab.q-focusable') === true);\n      const len = tabs.length;\n\n      if (len === 0) {\n        return;\n      }\n\n      if (keyCode === 36) {\n        // Home\n        scrollToTabEl(tabs[0]);\n        return true;\n      }\n\n      if (keyCode === 35) {\n        // End\n        scrollToTabEl(tabs[len - 1]);\n        return true;\n      }\n\n      const dirPrev = keyCode === (props.vertical === true ? 38\n      /* ArrowUp */\n      : 37\n      /* ArrowLeft */\n      );\n      const dirNext = keyCode === (props.vertical === true ? 40\n      /* ArrowDown */\n      : 39\n      /* ArrowRight */\n      );\n      const dir = dirPrev === true ? -1 : dirNext === true ? 1 : void 0;\n\n      if (dir !== void 0) {\n        const rtlDir = isRTL.value === true ? -1 : 1;\n        const index = tabs.indexOf(fromEl) + dir * rtlDir;\n\n        if (index >= 0 && index < len) {\n          scrollToTabEl(tabs[index]);\n          tabs[index].focus({\n            preventScroll: true\n          });\n        }\n\n        return true;\n      }\n    } // let's speed up execution of time-sensitive scrollTowards()\n    // with a computed variable by directly applying the minimal\n    // number of instructions on get/set functions\n\n\n    const posFn = computed(() => rtlPosCorrection.value === true ? {\n      get: content => Math.abs(content.scrollLeft),\n      set: (content, pos) => {\n        content.scrollLeft = -pos;\n      }\n    } : props.vertical === true ? {\n      get: content => content.scrollTop,\n      set: (content, pos) => {\n        content.scrollTop = pos;\n      }\n    } : {\n      get: content => content.scrollLeft,\n      set: (content, pos) => {\n        content.scrollLeft = pos;\n      }\n    });\n\n    function scrollTowards(value) {\n      const content = contentRef.value,\n            {\n        get,\n        set\n      } = posFn.value;\n      let done = false,\n          pos = get(content);\n      const direction = value < pos ? -1 : 1;\n      pos += direction * 5;\n\n      if (pos < 0) {\n        done = true;\n        pos = 0;\n      } else if (direction === -1 && pos <= value || direction === 1 && pos >= value) {\n        done = true;\n        pos = value;\n      }\n\n      set(content, pos);\n      localUpdateArrows();\n      return done;\n    }\n\n    function getRouteList() {\n      return tabList.filter(tab => tab.routerProps !== void 0 && tab.routerProps.hasRouterLink.value === true);\n    } // do not use directly; use verifyRouteModel() instead\n\n\n    function updateActiveRoute() {\n      let name = null,\n          wasActive = localFromRoute;\n      const best = {\n        matchedLen: 0,\n        hrefLen: 0,\n        exact: false,\n        found: false\n      },\n            {\n        hash\n      } = vm.proxy.$route,\n            model = currentModel.value;\n      let wasItActive = wasActive === true ? emptyFn : tab => {\n        if (model === tab.name.value) {\n          wasActive = true;\n          wasItActive = emptyFn;\n        }\n      };\n      const tabList = getRouteList();\n\n      for (const tab of tabList) {\n        const exact = tab.routerProps.exact.value === true;\n\n        if (tab.routerProps[exact === true ? 'linkIsExactActive' : 'linkIsActive'].value !== true || best.exact === true && exact !== true) {\n          wasItActive(tab);\n          continue;\n        }\n\n        const linkRoute = tab.routerProps.linkRoute.value,\n              tabHash = linkRoute.hash; // Vue Router does not match the hash too, even if link is set to \"exact\"\n\n        if (exact === true) {\n          if (hash === tabHash) {\n            name = tab.name.value;\n            break;\n          } else if (hash !== '' && tabHash !== '') {\n            wasItActive(tab);\n            continue;\n          }\n        }\n\n        const matchedLen = linkRoute.matched.length,\n              hrefLen = linkRoute.href.length - tabHash.length;\n\n        if (matchedLen === best.matchedLen ? hrefLen > best.hrefLen : matchedLen > best.matchedLen) {\n          name = tab.name.value;\n          Object.assign(best, {\n            matchedLen,\n            hrefLen,\n            exact\n          });\n          continue;\n        }\n\n        wasItActive(tab);\n      }\n\n      if (wasActive === true || name !== null) {\n        updateModel({\n          name,\n          setCurrent: true,\n          fromRoute: true\n        });\n      }\n    }\n\n    function onFocusin(e) {\n      removeFocusTimeout();\n\n      if (hasFocus.value !== true && rootRef.value !== null && e.target && typeof e.target.closest === 'function') {\n        const tab = e.target.closest('.q-tab'); // if the target is contained by a QTab/QRouteTab\n        // (it might be other elements focused, like additional QBtn)\n\n        if (tab && rootRef.value.contains(tab) === true) {\n          hasFocus.value = true;\n        }\n      }\n    }\n\n    function onFocusout() {\n      registerFocusTimeout(() => {\n        hasFocus.value = false;\n      }, 30);\n    }\n\n    function verifyRouteModel() {\n      if ($tabs.avoidRouteWatcher !== true) {\n        registerTimeout(updateActiveRoute);\n      }\n    }\n\n    function registerTab(getTab) {\n      tabList.push(getTab);\n      const routeList = getRouteList();\n\n      if (routeList.length > 0) {\n        if (unwatchRoute === void 0) {\n          unwatchRoute = watch(() => vm.proxy.$route, verifyRouteModel);\n        }\n\n        verifyRouteModel();\n      }\n    }\n    /*\n     * Vue has an aggressive diff (in-place replacement) so we cannot\n     * ensure that the instance getting destroyed is the actual tab\n     * reported here. As a result, we cannot use its name or check\n     * if it's a route one to make the necessary updates. We need to\n     * always check the existing list again and infer the changes.\n     */\n\n\n    function unregisterTab(tabData) {\n      tabList.splice(tabList.indexOf(tabData), 1);\n\n      if (unwatchRoute !== void 0) {\n        const routeList = getRouteList();\n\n        if (routeList.length === 0) {\n          unwatchRoute();\n          unwatchRoute = void 0;\n        }\n\n        verifyRouteModel();\n      }\n    }\n\n    const $tabs = {\n      currentModel,\n      tabProps,\n      hasFocus,\n      registerTab,\n      unregisterTab,\n      verifyRouteModel,\n      updateModel,\n      recalculateScroll,\n      onKbdNavigate,\n      avoidRouteWatcher: false\n    };\n    provide(tabsKey, $tabs);\n    onBeforeUnmount(() => {\n      clearTimeout(animateTimer);\n      unwatchRoute !== void 0 && unwatchRoute();\n    });\n    let shouldActivate = false;\n    onDeactivated(() => {\n      shouldActivate = true;\n    });\n    onActivated(() => {\n      shouldActivate === true && recalculateScroll();\n    });\n    return () => {\n      const child = [h(QResizeObserver, {\n        onResize: updateContainer\n      }), h('div', {\n        ref: contentRef,\n        class: innerClass.value,\n        onScroll: localUpdateArrows\n      }, hSlot(slots.default))];\n      arrowsEnabled.value === true && child.push(h(QIcon, {\n        class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon' + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n        name: props.leftIcon || $q.iconSet.tabs[props.vertical === true ? 'up' : 'left'],\n        onMousedown: scrollToStart,\n        onTouchstartPassive: scrollToStart,\n        onMouseup: stopAnimScroll,\n        onMouseleave: stopAnimScroll,\n        onTouchend: stopAnimScroll\n      }), h(QIcon, {\n        class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon' + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n        name: props.rightIcon || $q.iconSet.tabs[props.vertical === true ? 'down' : 'right'],\n        onMousedown: scrollToEnd,\n        onTouchstartPassive: scrollToEnd,\n        onMouseup: stopAnimScroll,\n        onMouseleave: stopAnimScroll,\n        onTouchend: stopAnimScroll\n      }));\n      return h('div', {\n        ref: rootRef,\n        class: classes.value,\n        role: 'tablist',\n        onFocusin,\n        onFocusout\n      }, child);\n    };\n  }\n\n});","map":{"version":3,"names":["h","ref","computed","watch","nextTick","onBeforeUnmount","onActivated","onDeactivated","getCurrentInstance","provide","QIcon","QResizeObserver","useTick","useTimeout","createComponent","noop","hSlot","tabsKey","rtlHasScrollBug","getIndicatorClass","color","top","vertical","pos","alignValues","emptyFn","name","props","modelValue","Number","String","align","type","default","validator","v","includes","breakpoint","Boolean","shrink","stretch","activeClass","activeColor","activeBgColor","indicatorColor","leftIcon","rightIcon","outsideArrows","mobileArrows","switchIndicator","narrowIndicator","inlineLabel","noCaps","dense","contentClass","Function","Array","setup","slots","emit","vm","proxy","$q","registerTick","registerScrollTick","registerTimeout","registerFocusTimeout","removeTimeout","removeFocusTimeout","rootRef","contentRef","currentModel","scrollable","leftArrow","rightArrow","justify","arrowsEnabled","platform","is","desktop","tabList","hasFocus","localFromRoute","animateTimer","scrollTimer","unwatchRoute","localUpdateArrows","value","updateArrowsFn","tabProps","indicatorClass","alignClass","classes","innerClass","mobile","domProps","container","content","scroll","isRTL","lang","rtl","rtlPosCorrection","updateModel","setCurrent","skipEmit","recalculateScroll","fromRoute","animate","isDeactivated","isUnmounted","updateContainer","width","offsetWidth","height","offsetHeight","domSize","size","scrollSize","Math","min","prototype","reduce","call","children","acc","el","localJustify","parseInt","oldName","newName","oldTab","find","tab","newTab","oldEl","tabIndicatorRef","newEl","clearTimeout","style","transition","transform","oldPos","getBoundingClientRect","newPos","left","setTimeout","scrollToTabEl","offset","floor","ceil","rect","scrollTop","abs","scrollLeft","scrollWidth","scrollHeight","animScrollTo","stopAnimScroll","scrollTowards","setInterval","scrollToStart","MAX_SAFE_INTEGER","scrollToEnd","clearInterval","onKbdNavigate","keyCode","fromEl","tabs","filter","matches","len","length","dirPrev","dirNext","dir","rtlDir","index","indexOf","focus","preventScroll","posFn","get","set","done","direction","getRouteList","routerProps","hasRouterLink","updateActiveRoute","wasActive","best","matchedLen","hrefLen","exact","found","hash","$route","model","wasItActive","linkRoute","tabHash","matched","href","Object","assign","onFocusin","e","target","closest","contains","onFocusout","verifyRouteModel","$tabs","avoidRouteWatcher","registerTab","getTab","push","routeList","unregisterTab","tabData","splice","shouldActivate","child","onResize","class","onScroll","iconSet","onMousedown","onTouchstartPassive","onMouseup","onMouseleave","onTouchend","role"],"sources":["C:/Users/BangJun/Desktop/VUE練習/app/node_modules/quasar/src/components/tabs/QTabs.js"],"sourcesContent":["import { h, ref, computed, watch, nextTick, onBeforeUnmount, onActivated, onDeactivated, getCurrentInstance, provide } from 'vue'\n\nimport QIcon from '../icon/QIcon.js'\nimport QResizeObserver from '../resize-observer/QResizeObserver.js'\n\nimport useTick from '../../composables/private/use-tick.js'\nimport useTimeout from '../../composables/private/use-timeout.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { noop } from '../../utils/event.js'\nimport { hSlot } from '../../utils/private/render.js'\nimport { tabsKey } from '../../utils/private/symbols.js'\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js'\n\nfunction getIndicatorClass (color, top, vertical) {\n  const pos = vertical === true\n    ? [ 'left', 'right' ]\n    : [ 'top', 'bottom' ]\n\n  return `absolute-${ top === true ? pos[ 0 ] : pos[ 1 ] }${ color ? ` text-${ color }` : '' }`\n}\n\nconst alignValues = [ 'left', 'center', 'right', 'justify' ]\nconst emptyFn = () => {}\n\nexport default createComponent({\n  name: 'QTabs',\n\n  props: {\n    modelValue: [ Number, String ],\n\n    align: {\n      type: String,\n      default: 'center',\n      validator: v => alignValues.includes(v)\n    },\n    breakpoint: {\n      type: [ String, Number ],\n      default: 600\n    },\n\n    vertical: Boolean,\n    shrink: Boolean,\n    stretch: Boolean,\n\n    activeClass: String,\n    activeColor: String,\n    activeBgColor: String,\n    indicatorColor: String,\n    leftIcon: String,\n    rightIcon: String,\n\n    outsideArrows: Boolean,\n    mobileArrows: Boolean,\n\n    switchIndicator: Boolean,\n\n    narrowIndicator: Boolean,\n    inlineLabel: Boolean,\n    noCaps: Boolean,\n\n    dense: Boolean,\n\n    contentClass: String,\n\n    'onUpdate:modelValue': [ Function, Array ]\n  },\n\n  setup (props, { slots, emit }) {\n    const vm = getCurrentInstance()\n    const { proxy: { $q } } = vm\n\n    const { registerTick: registerScrollTick } = useTick()\n    const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = useTimeout()\n    const { registerTimeout } = useTimeout()\n\n    const rootRef = ref(null)\n    const contentRef = ref(null)\n\n    const currentModel = ref(props.modelValue)\n    const scrollable = ref(false)\n    const leftArrow = ref(true)\n    const rightArrow = ref(false)\n    const justify = ref(false)\n\n    const arrowsEnabled = computed(() =>\n      $q.platform.is.desktop === true || props.mobileArrows === true\n    )\n\n    const tabList = []\n    const hasFocus = ref(false)\n\n    let localFromRoute = false, animateTimer, scrollTimer, unwatchRoute\n    let localUpdateArrows = arrowsEnabled.value === true\n      ? updateArrowsFn\n      : noop\n\n    const tabProps = computed(() => ({\n      activeClass: props.activeClass,\n      activeColor: props.activeColor,\n      activeBgColor: props.activeBgColor,\n      indicatorClass: getIndicatorClass(\n        props.indicatorColor,\n        props.switchIndicator,\n        props.vertical\n      ),\n      narrowIndicator: props.narrowIndicator,\n      inlineLabel: props.inlineLabel,\n      noCaps: props.noCaps\n    }))\n\n    const alignClass = computed(() => {\n      const align = scrollable.value === true\n        ? 'left'\n        : (justify.value === true ? 'justify' : props.align)\n\n      return `q-tabs__content--align-${ align }`\n    })\n\n    const classes = computed(() =>\n      'q-tabs row no-wrap items-center'\n      + ` q-tabs--${ scrollable.value === true ? '' : 'not-' }scrollable`\n      + ` q-tabs--${ props.vertical === true ? 'vertical' : 'horizontal' }`\n      + ` q-tabs__arrows--${ arrowsEnabled.value === true && props.outsideArrows === true ? 'outside' : 'inside' }`\n      + (props.dense === true ? ' q-tabs--dense' : '')\n      + (props.shrink === true ? ' col-shrink' : '')\n      + (props.stretch === true ? ' self-stretch' : '')\n    )\n\n    const innerClass = computed(() =>\n      'q-tabs__content row no-wrap items-center self-stretch hide-scrollbar relative-position '\n      + alignClass.value\n      + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')\n      + ($q.platform.is.mobile === true ? ' scroll' : '')\n    )\n\n    const domProps = computed(() => (\n      props.vertical === true\n        ? { container: 'height', content: 'offsetHeight', scroll: 'scrollHeight' }\n        : { container: 'width', content: 'offsetWidth', scroll: 'scrollWidth' }\n    ))\n\n    const isRTL = computed(() => props.vertical !== true && $q.lang.rtl === true)\n    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true)\n\n    watch(isRTL, localUpdateArrows)\n\n    watch(() => props.modelValue, name => {\n      updateModel({ name, setCurrent: true, skipEmit: true })\n    })\n\n    watch(() => props.outsideArrows, () => {\n      nextTick(recalculateScroll())\n    })\n\n    watch(arrowsEnabled, v => {\n      localUpdateArrows = v === true\n        ? updateArrowsFn\n        : noop\n\n      nextTick(recalculateScroll())\n    })\n\n    function updateModel ({ name, setCurrent, skipEmit, fromRoute }) {\n      if (currentModel.value !== name) {\n        skipEmit !== true && emit('update:modelValue', name)\n        if (\n          setCurrent === true\n          || props[ 'onUpdate:modelValue' ] === void 0\n        ) {\n          animate(currentModel.value, name)\n          currentModel.value = name\n        }\n      }\n\n      if (fromRoute !== void 0) {\n        localFromRoute = fromRoute\n      }\n    }\n\n    function recalculateScroll () {\n      registerScrollTick(() => {\n        if (vm.isDeactivated !== true && vm.isUnmounted !== true) {\n          updateContainer({\n            width: rootRef.value.offsetWidth,\n            height: rootRef.value.offsetHeight\n          })\n        }\n      })\n    }\n\n    function updateContainer (domSize) {\n      // it can be called faster than component being initialized\n      // so we need to protect against that case\n      // (one example of such case is the docs release notes page)\n      if (domProps.value === void 0 || contentRef.value === null) { return }\n\n      const\n        size = domSize[ domProps.value.container ],\n        scrollSize = Math.min(\n          contentRef.value[ domProps.value.scroll ],\n          Array.prototype.reduce.call(\n            contentRef.value.children,\n            (acc, el) => acc + (el[ domProps.value.content ] || 0),\n            0\n          )\n        ),\n        scroll = size > 0 && scrollSize > size // when there is no tab, in Chrome, size === 0 and scrollSize === 1\n\n      if (scrollable.value !== scroll) {\n        scrollable.value = scroll\n      }\n\n      // Arrows need to be updated even if the scroll status was already true\n      scroll === true && nextTick(localUpdateArrows)\n\n      const localJustify = size < parseInt(props.breakpoint, 10)\n\n      if (justify.value !== localJustify) {\n        justify.value = localJustify\n      }\n    }\n\n    function animate (oldName, newName) {\n      const\n        oldTab = oldName !== void 0 && oldName !== null && oldName !== ''\n          ? tabList.find(tab => tab.name.value === oldName)\n          : null,\n        newTab = newName !== void 0 && newName !== null && newName !== ''\n          ? tabList.find(tab => tab.name.value === newName)\n          : null\n\n      if (oldTab && newTab) {\n        const\n          oldEl = oldTab.tabIndicatorRef.value,\n          newEl = newTab.tabIndicatorRef.value\n\n        clearTimeout(animateTimer)\n\n        oldEl.style.transition = 'none'\n        oldEl.style.transform = 'none'\n        newEl.style.transition = 'none'\n        newEl.style.transform = 'none'\n\n        const\n          oldPos = oldEl.getBoundingClientRect(),\n          newPos = newEl.getBoundingClientRect()\n\n        newEl.style.transform = props.vertical === true\n          ? `translate3d(0,${ oldPos.top - newPos.top }px,0) scale3d(1,${ newPos.height ? oldPos.height / newPos.height : 1 },1)`\n          : `translate3d(${ oldPos.left - newPos.left }px,0,0) scale3d(${ newPos.width ? oldPos.width / newPos.width : 1 },1,1)`\n\n        // allow scope updates to kick in (QRouteTab needs more time)\n        nextTick(() => {\n          animateTimer = setTimeout(() => {\n            newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)'\n            newEl.style.transform = 'none'\n          }, 70)\n        })\n      }\n\n      if (newTab && scrollable.value === true) {\n        scrollToTabEl(newTab.rootRef.value)\n      }\n    }\n\n    function scrollToTabEl (el) {\n      const\n        { left, width, top, height } = contentRef.value.getBoundingClientRect(),\n        newPos = el.getBoundingClientRect()\n\n      let offset = props.vertical === true ? newPos.top - top : newPos.left - left\n\n      if (offset < 0) {\n        contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.floor(offset)\n        localUpdateArrows()\n        return\n      }\n\n      offset += props.vertical === true ? newPos.height - height : newPos.width - width\n      if (offset > 0) {\n        contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.ceil(offset)\n        localUpdateArrows()\n      }\n    }\n\n    function updateArrowsFn () {\n      const content = contentRef.value\n      if (content !== null) {\n        const\n          rect = content.getBoundingClientRect(),\n          pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft)\n\n        if (isRTL.value === true) {\n          leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1\n          rightArrow.value = pos > 0\n        }\n        else {\n          leftArrow.value = pos > 0\n          rightArrow.value = props.vertical === true\n            ? Math.ceil(pos + rect.height) < content.scrollHeight\n            : Math.ceil(pos + rect.width) < content.scrollWidth\n        }\n      }\n    }\n\n    function animScrollTo (value) {\n      stopAnimScroll()\n      scrollTowards(value)\n\n      scrollTimer = setInterval(() => {\n        if (scrollTowards(value) === true) {\n          stopAnimScroll()\n        }\n      }, 5)\n    }\n\n    function scrollToStart () {\n      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0)\n    }\n\n    function scrollToEnd () {\n      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER)\n    }\n\n    function stopAnimScroll () {\n      clearInterval(scrollTimer)\n    }\n\n    function onKbdNavigate (keyCode, fromEl) {\n      const tabs = Array.prototype.filter.call(\n        contentRef.value.children,\n        el => el === fromEl || (el.matches && el.matches('.q-tab.q-focusable') === true)\n      )\n\n      const len = tabs.length\n      if (len === 0) { return }\n\n      if (keyCode === 36) { // Home\n        scrollToTabEl(tabs[ 0 ])\n        return true\n      }\n      if (keyCode === 35) { // End\n        scrollToTabEl(tabs[ len - 1 ])\n        return true\n      }\n\n      const dirPrev = keyCode === (props.vertical === true ? 38 /* ArrowUp */ : 37 /* ArrowLeft */)\n      const dirNext = keyCode === (props.vertical === true ? 40 /* ArrowDown */ : 39 /* ArrowRight */)\n\n      const dir = dirPrev === true ? -1 : (dirNext === true ? 1 : void 0)\n\n      if (dir !== void 0) {\n        const rtlDir = isRTL.value === true ? -1 : 1\n        const index = tabs.indexOf(fromEl) + dir * rtlDir\n\n        if (index >= 0 && index < len) {\n          scrollToTabEl(tabs[ index ])\n          tabs[ index ].focus({ preventScroll: true })\n        }\n\n        return true\n      }\n    }\n\n    // let's speed up execution of time-sensitive scrollTowards()\n    // with a computed variable by directly applying the minimal\n    // number of instructions on get/set functions\n    const posFn = computed(() => (\n      rtlPosCorrection.value === true\n        ? { get: content => Math.abs(content.scrollLeft), set: (content, pos) => { content.scrollLeft = -pos } }\n        : (\n            props.vertical === true\n              ? { get: content => content.scrollTop, set: (content, pos) => { content.scrollTop = pos } }\n              : { get: content => content.scrollLeft, set: (content, pos) => { content.scrollLeft = pos } }\n          )\n    ))\n\n    function scrollTowards (value) {\n      const\n        content = contentRef.value,\n        { get, set } = posFn.value\n\n      let\n        done = false,\n        pos = get(content)\n\n      const direction = value < pos ? -1 : 1\n\n      pos += direction * 5\n\n      if (pos < 0) {\n        done = true\n        pos = 0\n      }\n      else if (\n        (direction === -1 && pos <= value)\n        || (direction === 1 && pos >= value)\n      ) {\n        done = true\n        pos = value\n      }\n\n      set(content, pos)\n      localUpdateArrows()\n\n      return done\n    }\n\n    function getRouteList () {\n      return tabList.filter(tab => tab.routerProps !== void 0 && tab.routerProps.hasRouterLink.value === true)\n    }\n\n    // do not use directly; use verifyRouteModel() instead\n    function updateActiveRoute () {\n      let name = null, wasActive = localFromRoute\n\n      const\n        best = { matchedLen: 0, hrefLen: 0, exact: false, found: false },\n        { hash } = vm.proxy.$route,\n        model = currentModel.value\n\n      let wasItActive = wasActive === true\n        ? emptyFn\n        : tab => {\n          if (model === tab.name.value) {\n            wasActive = true\n            wasItActive = emptyFn\n          }\n        }\n\n      const tabList = getRouteList()\n\n      for (const tab of tabList) {\n        const exact = tab.routerProps.exact.value === true\n\n        if (\n          tab.routerProps[ exact === true ? 'linkIsExactActive' : 'linkIsActive' ].value !== true\n          || (best.exact === true && exact !== true)\n        ) {\n          wasItActive(tab)\n          continue\n        }\n\n        const\n          linkRoute = tab.routerProps.linkRoute.value,\n          tabHash = linkRoute.hash\n\n        // Vue Router does not match the hash too, even if link is set to \"exact\"\n        if (exact === true) {\n          if (hash === tabHash) {\n            name = tab.name.value\n            break\n          }\n          else if (hash !== '' && tabHash !== '') {\n            wasItActive(tab)\n            continue\n          }\n        }\n\n        const\n          matchedLen = linkRoute.matched.length,\n          hrefLen = linkRoute.href.length - tabHash.length\n\n        if (\n          matchedLen === best.matchedLen\n            ? hrefLen > best.hrefLen\n            : matchedLen > best.matchedLen\n        ) {\n          name = tab.name.value\n          Object.assign(best, { matchedLen, hrefLen, exact })\n          continue\n        }\n\n        wasItActive(tab)\n      }\n\n      if (wasActive === true || name !== null) {\n        updateModel({ name, setCurrent: true, fromRoute: true })\n      }\n    }\n\n    function onFocusin (e) {\n      removeFocusTimeout()\n\n      if (\n        hasFocus.value !== true\n        && rootRef.value !== null\n        && e.target\n        && typeof e.target.closest === 'function'\n      ) {\n        const tab = e.target.closest('.q-tab')\n\n        // if the target is contained by a QTab/QRouteTab\n        // (it might be other elements focused, like additional QBtn)\n        if (tab && rootRef.value.contains(tab) === true) {\n          hasFocus.value = true\n        }\n      }\n    }\n\n    function onFocusout () {\n      registerFocusTimeout(() => { hasFocus.value = false }, 30)\n    }\n\n    function verifyRouteModel () {\n      if ($tabs.avoidRouteWatcher !== true) {\n        registerTimeout(updateActiveRoute)\n      }\n    }\n\n    function registerTab (getTab) {\n      tabList.push(getTab)\n\n      const routeList = getRouteList()\n\n      if (routeList.length > 0) {\n        if (unwatchRoute === void 0) {\n          unwatchRoute = watch(() => vm.proxy.$route, verifyRouteModel)\n        }\n\n        verifyRouteModel()\n      }\n    }\n\n    /*\n     * Vue has an aggressive diff (in-place replacement) so we cannot\n     * ensure that the instance getting destroyed is the actual tab\n     * reported here. As a result, we cannot use its name or check\n     * if it's a route one to make the necessary updates. We need to\n     * always check the existing list again and infer the changes.\n     */\n    function unregisterTab (tabData) {\n      tabList.splice(tabList.indexOf(tabData), 1)\n\n      if (unwatchRoute !== void 0) {\n        const routeList = getRouteList()\n\n        if (routeList.length === 0) {\n          unwatchRoute()\n          unwatchRoute = void 0\n        }\n\n        verifyRouteModel()\n      }\n    }\n\n    const $tabs = {\n      currentModel,\n      tabProps,\n      hasFocus,\n\n      registerTab,\n      unregisterTab,\n\n      verifyRouteModel,\n      updateModel,\n      recalculateScroll,\n      onKbdNavigate,\n\n      avoidRouteWatcher: false\n    }\n\n    provide(tabsKey, $tabs)\n\n    onBeforeUnmount(() => {\n      clearTimeout(animateTimer)\n      unwatchRoute !== void 0 && unwatchRoute()\n    })\n\n    let shouldActivate = false\n\n    onDeactivated(() => {\n      shouldActivate = true\n    })\n\n    onActivated(() => {\n      shouldActivate === true && recalculateScroll()\n    })\n\n    return () => {\n      const child = [\n        h(QResizeObserver, { onResize: updateContainer }),\n\n        h('div', {\n          ref: contentRef,\n          class: innerClass.value,\n          onScroll: localUpdateArrows\n        }, hSlot(slots.default))\n      ]\n\n      arrowsEnabled.value === true && child.push(\n        h(QIcon, {\n          class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon'\n            + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n          name: props.leftIcon || $q.iconSet.tabs[ props.vertical === true ? 'up' : 'left' ],\n          onMousedown: scrollToStart,\n          onTouchstartPassive: scrollToStart,\n          onMouseup: stopAnimScroll,\n          onMouseleave: stopAnimScroll,\n          onTouchend: stopAnimScroll\n        }),\n\n        h(QIcon, {\n          class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon'\n            + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n          name: props.rightIcon || $q.iconSet.tabs[ props.vertical === true ? 'down' : 'right' ],\n          onMousedown: scrollToEnd,\n          onTouchstartPassive: scrollToEnd,\n          onMouseup: stopAnimScroll,\n          onMouseleave: stopAnimScroll,\n          onTouchend: stopAnimScroll\n        })\n      )\n\n      return h('div', {\n        ref: rootRef,\n        class: classes.value,\n        role: 'tablist',\n        onFocusin,\n        onFocusout\n      }, child)\n    }\n  }\n})\n"],"mappings":";AAAA,SAASA,CAAT,EAAYC,GAAZ,EAAiBC,QAAjB,EAA2BC,KAA3B,EAAkCC,QAAlC,EAA4CC,eAA5C,EAA6DC,WAA7D,EAA0EC,aAA1E,EAAyFC,kBAAzF,EAA6GC,OAA7G,QAA4H,KAA5H;AAEA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,eAAP,MAA4B,uCAA5B;AAEA,OAAOC,OAAP,MAAoB,uCAApB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AAEA,SAASC,eAAT,QAAgC,+BAAhC;AACA,SAASC,IAAT,QAAqB,sBAArB;AACA,SAASC,KAAT,QAAsB,+BAAtB;AACA,SAASC,OAAT,QAAwB,gCAAxB;AACA,SAASC,eAAT,QAAgC,4BAAhC;;AAEA,SAASC,iBAAT,CAA4BC,KAA5B,EAAmCC,GAAnC,EAAwCC,QAAxC,EAAkD;EAChD,MAAMC,GAAG,GAAGD,QAAQ,KAAK,IAAb,GACR,CAAE,MAAF,EAAU,OAAV,CADQ,GAER,CAAE,KAAF,EAAS,QAAT,CAFJ;EAIA,OAAQ,YAAYD,GAAG,KAAK,IAAR,GAAeE,GAAG,CAAE,CAAF,CAAlB,GAA0BA,GAAG,CAAE,CAAF,CAAO,GAAGH,KAAK,GAAI,SAASA,KAAO,EAApB,GAAwB,EAAI,EAA5F;AACD;;AAED,MAAMI,WAAW,GAAG,CAAE,MAAF,EAAU,QAAV,EAAoB,OAApB,EAA6B,SAA7B,CAApB;;AACA,MAAMC,OAAO,GAAG,MAAM,CAAE,CAAxB;;AAEA,eAAeX,eAAe,CAAC;EAC7BY,IAAI,EAAE,OADuB;EAG7BC,KAAK,EAAE;IACLC,UAAU,EAAE,CAAEC,MAAF,EAAUC,MAAV,CADP;IAGLC,KAAK,EAAE;MACLC,IAAI,EAAEF,MADD;MAELG,OAAO,EAAE,QAFJ;MAGLC,SAAS,EAAEC,CAAC,IAAIX,WAAW,CAACY,QAAZ,CAAqBD,CAArB;IAHX,CAHF;IAQLE,UAAU,EAAE;MACVL,IAAI,EAAE,CAAEF,MAAF,EAAUD,MAAV,CADI;MAEVI,OAAO,EAAE;IAFC,CARP;IAaLX,QAAQ,EAAEgB,OAbL;IAcLC,MAAM,EAAED,OAdH;IAeLE,OAAO,EAAEF,OAfJ;IAiBLG,WAAW,EAAEX,MAjBR;IAkBLY,WAAW,EAAEZ,MAlBR;IAmBLa,aAAa,EAAEb,MAnBV;IAoBLc,cAAc,EAAEd,MApBX;IAqBLe,QAAQ,EAAEf,MArBL;IAsBLgB,SAAS,EAAEhB,MAtBN;IAwBLiB,aAAa,EAAET,OAxBV;IAyBLU,YAAY,EAAEV,OAzBT;IA2BLW,eAAe,EAAEX,OA3BZ;IA6BLY,eAAe,EAAEZ,OA7BZ;IA8BLa,WAAW,EAAEb,OA9BR;IA+BLc,MAAM,EAAEd,OA/BH;IAiCLe,KAAK,EAAEf,OAjCF;IAmCLgB,YAAY,EAAExB,MAnCT;IAqCL,uBAAuB,CAAEyB,QAAF,EAAYC,KAAZ;EArClB,CAHsB;;EA2C7BC,KAAK,CAAE9B,KAAF,EAAS;IAAE+B,KAAF;IAASC;EAAT,CAAT,EAA0B;IAC7B,MAAMC,EAAE,GAAGpD,kBAAkB,EAA7B;IACA,MAAM;MAAEqD,KAAK,EAAE;QAAEC;MAAF;IAAT,IAAoBF,EAA1B;IAEA,MAAM;MAAEG,YAAY,EAAEC;IAAhB,IAAuCpD,OAAO,EAApD;IACA,MAAM;MAAEqD,eAAe,EAAEC,oBAAnB;MAAyCC,aAAa,EAAEC;IAAxD,IAA+EvD,UAAU,EAA/F;IACA,MAAM;MAAEoD;IAAF,IAAsBpD,UAAU,EAAtC;IAEA,MAAMwD,OAAO,GAAGpE,GAAG,CAAC,IAAD,CAAnB;IACA,MAAMqE,UAAU,GAAGrE,GAAG,CAAC,IAAD,CAAtB;IAEA,MAAMsE,YAAY,GAAGtE,GAAG,CAAC0B,KAAK,CAACC,UAAP,CAAxB;IACA,MAAM4C,UAAU,GAAGvE,GAAG,CAAC,KAAD,CAAtB;IACA,MAAMwE,SAAS,GAAGxE,GAAG,CAAC,IAAD,CAArB;IACA,MAAMyE,UAAU,GAAGzE,GAAG,CAAC,KAAD,CAAtB;IACA,MAAM0E,OAAO,GAAG1E,GAAG,CAAC,KAAD,CAAnB;IAEA,MAAM2E,aAAa,GAAG1E,QAAQ,CAAC,MAC7B4D,EAAE,CAACe,QAAH,CAAYC,EAAZ,CAAeC,OAAf,KAA2B,IAA3B,IAAmCpD,KAAK,CAACqB,YAAN,KAAuB,IAD9B,CAA9B;IAIA,MAAMgC,OAAO,GAAG,EAAhB;IACA,MAAMC,QAAQ,GAAGhF,GAAG,CAAC,KAAD,CAApB;IAEA,IAAIiF,cAAc,GAAG,KAArB;IAAA,IAA4BC,YAA5B;IAAA,IAA0CC,WAA1C;IAAA,IAAuDC,YAAvD;IACA,IAAIC,iBAAiB,GAAGV,aAAa,CAACW,KAAd,KAAwB,IAAxB,GACpBC,cADoB,GAEpBzE,IAFJ;IAIA,MAAM0E,QAAQ,GAAGvF,QAAQ,CAAC,OAAO;MAC/BuC,WAAW,EAAEd,KAAK,CAACc,WADY;MAE/BC,WAAW,EAAEf,KAAK,CAACe,WAFY;MAG/BC,aAAa,EAAEhB,KAAK,CAACgB,aAHU;MAI/B+C,cAAc,EAAEvE,iBAAiB,CAC/BQ,KAAK,CAACiB,cADyB,EAE/BjB,KAAK,CAACsB,eAFyB,EAG/BtB,KAAK,CAACL,QAHyB,CAJF;MAS/B4B,eAAe,EAAEvB,KAAK,CAACuB,eATQ;MAU/BC,WAAW,EAAExB,KAAK,CAACwB,WAVY;MAW/BC,MAAM,EAAEzB,KAAK,CAACyB;IAXiB,CAAP,CAAD,CAAzB;IAcA,MAAMuC,UAAU,GAAGzF,QAAQ,CAAC,MAAM;MAChC,MAAM6B,KAAK,GAAGyC,UAAU,CAACe,KAAX,KAAqB,IAArB,GACV,MADU,GAETZ,OAAO,CAACY,KAAR,KAAkB,IAAlB,GAAyB,SAAzB,GAAqC5D,KAAK,CAACI,KAFhD;MAIA,OAAQ,0BAA0BA,KAAO,EAAzC;IACD,CAN0B,CAA3B;IAQA,MAAM6D,OAAO,GAAG1F,QAAQ,CAAC,MACvB,oCACG,YAAYsE,UAAU,CAACe,KAAX,KAAqB,IAArB,GAA4B,EAA5B,GAAiC,MAAQ,YADxD,GAEG,YAAY5D,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B,UAA1B,GAAuC,YAAc,EAFpE,GAGG,oBAAoBsD,aAAa,CAACW,KAAd,KAAwB,IAAxB,IAAgC5D,KAAK,CAACoB,aAAN,KAAwB,IAAxD,GAA+D,SAA/D,GAA2E,QAAU,EAH5G,IAIGpB,KAAK,CAAC0B,KAAN,KAAgB,IAAhB,GAAuB,gBAAvB,GAA0C,EAJ7C,KAKG1B,KAAK,CAACY,MAAN,KAAiB,IAAjB,GAAwB,aAAxB,GAAwC,EAL3C,KAMGZ,KAAK,CAACa,OAAN,KAAkB,IAAlB,GAAyB,eAAzB,GAA2C,EAN9C,CADsB,CAAxB;IAUA,MAAMqD,UAAU,GAAG3F,QAAQ,CAAC,MAC1B,4FACEyF,UAAU,CAACJ,KADb,IAEG5D,KAAK,CAAC2B,YAAN,KAAuB,KAAK,CAA5B,GAAiC,IAAI3B,KAAK,CAAC2B,YAAc,EAAzD,GAA6D,EAFhE,KAGGQ,EAAE,CAACe,QAAH,CAAYC,EAAZ,CAAegB,MAAf,KAA0B,IAA1B,GAAiC,SAAjC,GAA6C,EAHhD,CADyB,CAA3B;IAOA,MAAMC,QAAQ,GAAG7F,QAAQ,CAAC,MACxByB,KAAK,CAACL,QAAN,KAAmB,IAAnB,GACI;MAAE0E,SAAS,EAAE,QAAb;MAAuBC,OAAO,EAAE,cAAhC;MAAgDC,MAAM,EAAE;IAAxD,CADJ,GAEI;MAAEF,SAAS,EAAE,OAAb;MAAsBC,OAAO,EAAE,aAA/B;MAA8CC,MAAM,EAAE;IAAtD,CAHmB,CAAzB;IAMA,MAAMC,KAAK,GAAGjG,QAAQ,CAAC,MAAMyB,KAAK,CAACL,QAAN,KAAmB,IAAnB,IAA2BwC,EAAE,CAACsC,IAAH,CAAQC,GAAR,KAAgB,IAAlD,CAAtB;IACA,MAAMC,gBAAgB,GAAGpG,QAAQ,CAAC,MAAMgB,eAAe,KAAK,KAApB,IAA6BiF,KAAK,CAACZ,KAAN,KAAgB,IAApD,CAAjC;IAEApF,KAAK,CAACgG,KAAD,EAAQb,iBAAR,CAAL;IAEAnF,KAAK,CAAC,MAAMwB,KAAK,CAACC,UAAb,EAAyBF,IAAI,IAAI;MACpC6E,WAAW,CAAC;QAAE7E,IAAF;QAAQ8E,UAAU,EAAE,IAApB;QAA0BC,QAAQ,EAAE;MAApC,CAAD,CAAX;IACD,CAFI,CAAL;IAIAtG,KAAK,CAAC,MAAMwB,KAAK,CAACoB,aAAb,EAA4B,MAAM;MACrC3C,QAAQ,CAACsG,iBAAiB,EAAlB,CAAR;IACD,CAFI,CAAL;IAIAvG,KAAK,CAACyE,aAAD,EAAgBzC,CAAC,IAAI;MACxBmD,iBAAiB,GAAGnD,CAAC,KAAK,IAAN,GAChBqD,cADgB,GAEhBzE,IAFJ;MAIAX,QAAQ,CAACsG,iBAAiB,EAAlB,CAAR;IACD,CANI,CAAL;;IAQA,SAASH,WAAT,CAAsB;MAAE7E,IAAF;MAAQ8E,UAAR;MAAoBC,QAApB;MAA8BE;IAA9B,CAAtB,EAAiE;MAC/D,IAAIpC,YAAY,CAACgB,KAAb,KAAuB7D,IAA3B,EAAiC;QAC/B+E,QAAQ,KAAK,IAAb,IAAqB9C,IAAI,CAAC,mBAAD,EAAsBjC,IAAtB,CAAzB;;QACA,IACE8E,UAAU,KAAK,IAAf,IACG7E,KAAK,CAAE,qBAAF,CAAL,KAAmC,KAAK,CAF7C,EAGE;UACAiF,OAAO,CAACrC,YAAY,CAACgB,KAAd,EAAqB7D,IAArB,CAAP;UACA6C,YAAY,CAACgB,KAAb,GAAqB7D,IAArB;QACD;MACF;;MAED,IAAIiF,SAAS,KAAK,KAAK,CAAvB,EAA0B;QACxBzB,cAAc,GAAGyB,SAAjB;MACD;IACF;;IAED,SAASD,iBAAT,GAA8B;MAC5B1C,kBAAkB,CAAC,MAAM;QACvB,IAAIJ,EAAE,CAACiD,aAAH,KAAqB,IAArB,IAA6BjD,EAAE,CAACkD,WAAH,KAAmB,IAApD,EAA0D;UACxDC,eAAe,CAAC;YACdC,KAAK,EAAE3C,OAAO,CAACkB,KAAR,CAAc0B,WADP;YAEdC,MAAM,EAAE7C,OAAO,CAACkB,KAAR,CAAc4B;UAFR,CAAD,CAAf;QAID;MACF,CAPiB,CAAlB;IAQD;;IAED,SAASJ,eAAT,CAA0BK,OAA1B,EAAmC;MACjC;MACA;MACA;MACA,IAAIrB,QAAQ,CAACR,KAAT,KAAmB,KAAK,CAAxB,IAA6BjB,UAAU,CAACiB,KAAX,KAAqB,IAAtD,EAA4D;QAAE;MAAQ;;MAEtE,MACE8B,IAAI,GAAGD,OAAO,CAAErB,QAAQ,CAACR,KAAT,CAAeS,SAAjB,CADhB;MAAA,MAEEsB,UAAU,GAAGC,IAAI,CAACC,GAAL,CACXlD,UAAU,CAACiB,KAAX,CAAkBQ,QAAQ,CAACR,KAAT,CAAeW,MAAjC,CADW,EAEX1C,KAAK,CAACiE,SAAN,CAAgBC,MAAhB,CAAuBC,IAAvB,CACErD,UAAU,CAACiB,KAAX,CAAiBqC,QADnB,EAEE,CAACC,GAAD,EAAMC,EAAN,KAAaD,GAAG,IAAIC,EAAE,CAAE/B,QAAQ,CAACR,KAAT,CAAeU,OAAjB,CAAF,IAAgC,CAApC,CAFlB,EAGE,CAHF,CAFW,CAFf;MAAA,MAUEC,MAAM,GAAGmB,IAAI,GAAG,CAAP,IAAYC,UAAU,GAAGD,IAVpC,CANiC,CAgBQ;;MAEzC,IAAI7C,UAAU,CAACe,KAAX,KAAqBW,MAAzB,EAAiC;QAC/B1B,UAAU,CAACe,KAAX,GAAmBW,MAAnB;MACD,CApBgC,CAsBjC;;;MACAA,MAAM,KAAK,IAAX,IAAmB9F,QAAQ,CAACkF,iBAAD,CAA3B;MAEA,MAAMyC,YAAY,GAAGV,IAAI,GAAGW,QAAQ,CAACrG,KAAK,CAACU,UAAP,EAAmB,EAAnB,CAApC;;MAEA,IAAIsC,OAAO,CAACY,KAAR,KAAkBwC,YAAtB,EAAoC;QAClCpD,OAAO,CAACY,KAAR,GAAgBwC,YAAhB;MACD;IACF;;IAED,SAASnB,OAAT,CAAkBqB,OAAlB,EAA2BC,OAA3B,EAAoC;MAClC,MACEC,MAAM,GAAGF,OAAO,KAAK,KAAK,CAAjB,IAAsBA,OAAO,KAAK,IAAlC,IAA0CA,OAAO,KAAK,EAAtD,GACLjD,OAAO,CAACoD,IAAR,CAAaC,GAAG,IAAIA,GAAG,CAAC3G,IAAJ,CAAS6D,KAAT,KAAmB0C,OAAvC,CADK,GAEL,IAHN;MAAA,MAIEK,MAAM,GAAGJ,OAAO,KAAK,KAAK,CAAjB,IAAsBA,OAAO,KAAK,IAAlC,IAA0CA,OAAO,KAAK,EAAtD,GACLlD,OAAO,CAACoD,IAAR,CAAaC,GAAG,IAAIA,GAAG,CAAC3G,IAAJ,CAAS6D,KAAT,KAAmB2C,OAAvC,CADK,GAEL,IANN;;MAQA,IAAIC,MAAM,IAAIG,MAAd,EAAsB;QACpB,MACEC,KAAK,GAAGJ,MAAM,CAACK,eAAP,CAAuBjD,KADjC;QAAA,MAEEkD,KAAK,GAAGH,MAAM,CAACE,eAAP,CAAuBjD,KAFjC;QAIAmD,YAAY,CAACvD,YAAD,CAAZ;QAEAoD,KAAK,CAACI,KAAN,CAAYC,UAAZ,GAAyB,MAAzB;QACAL,KAAK,CAACI,KAAN,CAAYE,SAAZ,GAAwB,MAAxB;QACAJ,KAAK,CAACE,KAAN,CAAYC,UAAZ,GAAyB,MAAzB;QACAH,KAAK,CAACE,KAAN,CAAYE,SAAZ,GAAwB,MAAxB;QAEA,MACEC,MAAM,GAAGP,KAAK,CAACQ,qBAAN,EADX;QAAA,MAEEC,MAAM,GAAGP,KAAK,CAACM,qBAAN,EAFX;QAIAN,KAAK,CAACE,KAAN,CAAYE,SAAZ,GAAwBlH,KAAK,CAACL,QAAN,KAAmB,IAAnB,GACnB,iBAAiBwH,MAAM,CAACzH,GAAP,GAAa2H,MAAM,CAAC3H,GAAK,mBAAmB2H,MAAM,CAAC9B,MAAP,GAAgB4B,MAAM,CAAC5B,MAAP,GAAgB8B,MAAM,CAAC9B,MAAvC,GAAgD,CAAG,KAD7F,GAEnB,eAAe4B,MAAM,CAACG,IAAP,GAAcD,MAAM,CAACC,IAAM,mBAAmBD,MAAM,CAAChC,KAAP,GAAe8B,MAAM,CAAC9B,KAAP,GAAegC,MAAM,CAAChC,KAArC,GAA6C,CAAG,OAFlH,CAhBoB,CAoBpB;;QACA5G,QAAQ,CAAC,MAAM;UACb+E,YAAY,GAAG+D,UAAU,CAAC,MAAM;YAC9BT,KAAK,CAACE,KAAN,CAAYC,UAAZ,GAAyB,2CAAzB;YACAH,KAAK,CAACE,KAAN,CAAYE,SAAZ,GAAwB,MAAxB;UACD,CAHwB,EAGtB,EAHsB,CAAzB;QAID,CALO,CAAR;MAMD;;MAED,IAAIP,MAAM,IAAI9D,UAAU,CAACe,KAAX,KAAqB,IAAnC,EAAyC;QACvC4D,aAAa,CAACb,MAAM,CAACjE,OAAP,CAAekB,KAAhB,CAAb;MACD;IACF;;IAED,SAAS4D,aAAT,CAAwBrB,EAAxB,EAA4B;MAC1B,MACE;QAAEmB,IAAF;QAAQjC,KAAR;QAAe3F,GAAf;QAAoB6F;MAApB,IAA+B5C,UAAU,CAACiB,KAAX,CAAiBwD,qBAAjB,EADjC;MAAA,MAEEC,MAAM,GAAGlB,EAAE,CAACiB,qBAAH,EAFX;MAIA,IAAIK,MAAM,GAAGzH,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B0H,MAAM,CAAC3H,GAAP,GAAaA,GAAvC,GAA6C2H,MAAM,CAACC,IAAP,GAAcA,IAAxE;;MAEA,IAAIG,MAAM,GAAG,CAAb,EAAgB;QACd9E,UAAU,CAACiB,KAAX,CAAkB5D,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B,WAA1B,GAAwC,YAA1D,KAA4EiG,IAAI,CAAC8B,KAAL,CAAWD,MAAX,CAA5E;QACA9D,iBAAiB;QACjB;MACD;;MAED8D,MAAM,IAAIzH,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B0H,MAAM,CAAC9B,MAAP,GAAgBA,MAA1C,GAAmD8B,MAAM,CAAChC,KAAP,GAAeA,KAA5E;;MACA,IAAIoC,MAAM,GAAG,CAAb,EAAgB;QACd9E,UAAU,CAACiB,KAAX,CAAkB5D,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B,WAA1B,GAAwC,YAA1D,KAA4EiG,IAAI,CAAC+B,IAAL,CAAUF,MAAV,CAA5E;QACA9D,iBAAiB;MAClB;IACF;;IAED,SAASE,cAAT,GAA2B;MACzB,MAAMS,OAAO,GAAG3B,UAAU,CAACiB,KAA3B;;MACA,IAAIU,OAAO,KAAK,IAAhB,EAAsB;QACpB,MACEsD,IAAI,GAAGtD,OAAO,CAAC8C,qBAAR,EADT;QAAA,MAEExH,GAAG,GAAGI,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B2E,OAAO,CAACuD,SAAlC,GAA8CjC,IAAI,CAACkC,GAAL,CAASxD,OAAO,CAACyD,UAAjB,CAFtD;;QAIA,IAAIvD,KAAK,CAACZ,KAAN,KAAgB,IAApB,EAA0B;UACxBd,SAAS,CAACc,KAAV,GAAkBgC,IAAI,CAAC+B,IAAL,CAAU/H,GAAG,GAAGgI,IAAI,CAACvC,KAArB,IAA8Bf,OAAO,CAAC0D,WAAR,GAAsB,CAAtE;UACAjF,UAAU,CAACa,KAAX,GAAmBhE,GAAG,GAAG,CAAzB;QACD,CAHD,MAIK;UACHkD,SAAS,CAACc,KAAV,GAAkBhE,GAAG,GAAG,CAAxB;UACAmD,UAAU,CAACa,KAAX,GAAmB5D,KAAK,CAACL,QAAN,KAAmB,IAAnB,GACfiG,IAAI,CAAC+B,IAAL,CAAU/H,GAAG,GAAGgI,IAAI,CAACrC,MAArB,IAA+BjB,OAAO,CAAC2D,YADxB,GAEfrC,IAAI,CAAC+B,IAAL,CAAU/H,GAAG,GAAGgI,IAAI,CAACvC,KAArB,IAA8Bf,OAAO,CAAC0D,WAF1C;QAGD;MACF;IACF;;IAED,SAASE,YAAT,CAAuBtE,KAAvB,EAA8B;MAC5BuE,cAAc;MACdC,aAAa,CAACxE,KAAD,CAAb;MAEAH,WAAW,GAAG4E,WAAW,CAAC,MAAM;QAC9B,IAAID,aAAa,CAACxE,KAAD,CAAb,KAAyB,IAA7B,EAAmC;UACjCuE,cAAc;QACf;MACF,CAJwB,EAItB,CAJsB,CAAzB;IAKD;;IAED,SAASG,aAAT,GAA0B;MACxBJ,YAAY,CAACvD,gBAAgB,CAACf,KAAjB,KAA2B,IAA3B,GAAkC1D,MAAM,CAACqI,gBAAzC,GAA4D,CAA7D,CAAZ;IACD;;IAED,SAASC,WAAT,GAAwB;MACtBN,YAAY,CAACvD,gBAAgB,CAACf,KAAjB,KAA2B,IAA3B,GAAkC,CAAlC,GAAsC1D,MAAM,CAACqI,gBAA9C,CAAZ;IACD;;IAED,SAASJ,cAAT,GAA2B;MACzBM,aAAa,CAAChF,WAAD,CAAb;IACD;;IAED,SAASiF,aAAT,CAAwBC,OAAxB,EAAiCC,MAAjC,EAAyC;MACvC,MAAMC,IAAI,GAAGhH,KAAK,CAACiE,SAAN,CAAgBgD,MAAhB,CAAuB9C,IAAvB,CACXrD,UAAU,CAACiB,KAAX,CAAiBqC,QADN,EAEXE,EAAE,IAAIA,EAAE,KAAKyC,MAAP,IAAkBzC,EAAE,CAAC4C,OAAH,IAAc5C,EAAE,CAAC4C,OAAH,CAAW,oBAAX,MAAqC,IAFhE,CAAb;MAKA,MAAMC,GAAG,GAAGH,IAAI,CAACI,MAAjB;;MACA,IAAID,GAAG,KAAK,CAAZ,EAAe;QAAE;MAAQ;;MAEzB,IAAIL,OAAO,KAAK,EAAhB,EAAoB;QAAE;QACpBnB,aAAa,CAACqB,IAAI,CAAE,CAAF,CAAL,CAAb;QACA,OAAO,IAAP;MACD;;MACD,IAAIF,OAAO,KAAK,EAAhB,EAAoB;QAAE;QACpBnB,aAAa,CAACqB,IAAI,CAAEG,GAAG,GAAG,CAAR,CAAL,CAAb;QACA,OAAO,IAAP;MACD;;MAED,MAAME,OAAO,GAAGP,OAAO,MAAM3I,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B;MAAG;MAA7B,EAA6C;MAAG;MAAtD,CAAvB;MACA,MAAMwJ,OAAO,GAAGR,OAAO,MAAM3I,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B;MAAG;MAA7B,EAA+C;MAAG;MAAxD,CAAvB;MAEA,MAAMyJ,GAAG,GAAGF,OAAO,KAAK,IAAZ,GAAmB,CAAC,CAApB,GAAyBC,OAAO,KAAK,IAAZ,GAAmB,CAAnB,GAAuB,KAAK,CAAjE;;MAEA,IAAIC,GAAG,KAAK,KAAK,CAAjB,EAAoB;QAClB,MAAMC,MAAM,GAAG7E,KAAK,CAACZ,KAAN,KAAgB,IAAhB,GAAuB,CAAC,CAAxB,GAA4B,CAA3C;QACA,MAAM0F,KAAK,GAAGT,IAAI,CAACU,OAAL,CAAaX,MAAb,IAAuBQ,GAAG,GAAGC,MAA3C;;QAEA,IAAIC,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAGN,GAA1B,EAA+B;UAC7BxB,aAAa,CAACqB,IAAI,CAAES,KAAF,CAAL,CAAb;UACAT,IAAI,CAAES,KAAF,CAAJ,CAAcE,KAAd,CAAoB;YAAEC,aAAa,EAAE;UAAjB,CAApB;QACD;;QAED,OAAO,IAAP;MACD;IACF,CAvS4B,CAyS7B;IACA;IACA;;;IACA,MAAMC,KAAK,GAAGnL,QAAQ,CAAC,MACrBoG,gBAAgB,CAACf,KAAjB,KAA2B,IAA3B,GACI;MAAE+F,GAAG,EAAErF,OAAO,IAAIsB,IAAI,CAACkC,GAAL,CAASxD,OAAO,CAACyD,UAAjB,CAAlB;MAAgD6B,GAAG,EAAE,CAACtF,OAAD,EAAU1E,GAAV,KAAkB;QAAE0E,OAAO,CAACyD,UAAR,GAAqB,CAACnI,GAAtB;MAA2B;IAApG,CADJ,GAGMI,KAAK,CAACL,QAAN,KAAmB,IAAnB,GACI;MAAEgK,GAAG,EAAErF,OAAO,IAAIA,OAAO,CAACuD,SAA1B;MAAqC+B,GAAG,EAAE,CAACtF,OAAD,EAAU1E,GAAV,KAAkB;QAAE0E,OAAO,CAACuD,SAAR,GAAoBjI,GAApB;MAAyB;IAAvF,CADJ,GAEI;MAAE+J,GAAG,EAAErF,OAAO,IAAIA,OAAO,CAACyD,UAA1B;MAAsC6B,GAAG,EAAE,CAACtF,OAAD,EAAU1E,GAAV,KAAkB;QAAE0E,OAAO,CAACyD,UAAR,GAAqBnI,GAArB;MAA0B;IAAzF,CANU,CAAtB;;IAUA,SAASwI,aAAT,CAAwBxE,KAAxB,EAA+B;MAC7B,MACEU,OAAO,GAAG3B,UAAU,CAACiB,KADvB;MAAA,MAEE;QAAE+F,GAAF;QAAOC;MAAP,IAAeF,KAAK,CAAC9F,KAFvB;MAIA,IACEiG,IAAI,GAAG,KADT;MAAA,IAEEjK,GAAG,GAAG+J,GAAG,CAACrF,OAAD,CAFX;MAIA,MAAMwF,SAAS,GAAGlG,KAAK,GAAGhE,GAAR,GAAc,CAAC,CAAf,GAAmB,CAArC;MAEAA,GAAG,IAAIkK,SAAS,GAAG,CAAnB;;MAEA,IAAIlK,GAAG,GAAG,CAAV,EAAa;QACXiK,IAAI,GAAG,IAAP;QACAjK,GAAG,GAAG,CAAN;MACD,CAHD,MAIK,IACFkK,SAAS,KAAK,CAAC,CAAf,IAAoBlK,GAAG,IAAIgE,KAA5B,IACIkG,SAAS,KAAK,CAAd,IAAmBlK,GAAG,IAAIgE,KAF3B,EAGH;QACAiG,IAAI,GAAG,IAAP;QACAjK,GAAG,GAAGgE,KAAN;MACD;;MAEDgG,GAAG,CAACtF,OAAD,EAAU1E,GAAV,CAAH;MACA+D,iBAAiB;MAEjB,OAAOkG,IAAP;IACD;;IAED,SAASE,YAAT,GAAyB;MACvB,OAAO1G,OAAO,CAACyF,MAAR,CAAepC,GAAG,IAAIA,GAAG,CAACsD,WAAJ,KAAoB,KAAK,CAAzB,IAA8BtD,GAAG,CAACsD,WAAJ,CAAgBC,aAAhB,CAA8BrG,KAA9B,KAAwC,IAA5F,CAAP;IACD,CAvV4B,CAyV7B;;;IACA,SAASsG,iBAAT,GAA8B;MAC5B,IAAInK,IAAI,GAAG,IAAX;MAAA,IAAiBoK,SAAS,GAAG5G,cAA7B;MAEA,MACE6G,IAAI,GAAG;QAAEC,UAAU,EAAE,CAAd;QAAiBC,OAAO,EAAE,CAA1B;QAA6BC,KAAK,EAAE,KAApC;QAA2CC,KAAK,EAAE;MAAlD,CADT;MAAA,MAEE;QAAEC;MAAF,IAAWxI,EAAE,CAACC,KAAH,CAASwI,MAFtB;MAAA,MAGEC,KAAK,GAAG/H,YAAY,CAACgB,KAHvB;MAKA,IAAIgH,WAAW,GAAGT,SAAS,KAAK,IAAd,GACdrK,OADc,GAEd4G,GAAG,IAAI;QACP,IAAIiE,KAAK,KAAKjE,GAAG,CAAC3G,IAAJ,CAAS6D,KAAvB,EAA8B;UAC5BuG,SAAS,GAAG,IAAZ;UACAS,WAAW,GAAG9K,OAAd;QACD;MACF,CAPH;MASA,MAAMuD,OAAO,GAAG0G,YAAY,EAA5B;;MAEA,KAAK,MAAMrD,GAAX,IAAkBrD,OAAlB,EAA2B;QACzB,MAAMkH,KAAK,GAAG7D,GAAG,CAACsD,WAAJ,CAAgBO,KAAhB,CAAsB3G,KAAtB,KAAgC,IAA9C;;QAEA,IACE8C,GAAG,CAACsD,WAAJ,CAAiBO,KAAK,KAAK,IAAV,GAAiB,mBAAjB,GAAuC,cAAxD,EAAyE3G,KAAzE,KAAmF,IAAnF,IACIwG,IAAI,CAACG,KAAL,KAAe,IAAf,IAAuBA,KAAK,KAAK,IAFvC,EAGE;UACAK,WAAW,CAAClE,GAAD,CAAX;UACA;QACD;;QAED,MACEmE,SAAS,GAAGnE,GAAG,CAACsD,WAAJ,CAAgBa,SAAhB,CAA0BjH,KADxC;QAAA,MAEEkH,OAAO,GAAGD,SAAS,CAACJ,IAFtB,CAXyB,CAezB;;QACA,IAAIF,KAAK,KAAK,IAAd,EAAoB;UAClB,IAAIE,IAAI,KAAKK,OAAb,EAAsB;YACpB/K,IAAI,GAAG2G,GAAG,CAAC3G,IAAJ,CAAS6D,KAAhB;YACA;UACD,CAHD,MAIK,IAAI6G,IAAI,KAAK,EAAT,IAAeK,OAAO,KAAK,EAA/B,EAAmC;YACtCF,WAAW,CAAClE,GAAD,CAAX;YACA;UACD;QACF;;QAED,MACE2D,UAAU,GAAGQ,SAAS,CAACE,OAAV,CAAkB9B,MADjC;QAAA,MAEEqB,OAAO,GAAGO,SAAS,CAACG,IAAV,CAAe/B,MAAf,GAAwB6B,OAAO,CAAC7B,MAF5C;;QAIA,IACEoB,UAAU,KAAKD,IAAI,CAACC,UAApB,GACIC,OAAO,GAAGF,IAAI,CAACE,OADnB,GAEID,UAAU,GAAGD,IAAI,CAACC,UAHxB,EAIE;UACAtK,IAAI,GAAG2G,GAAG,CAAC3G,IAAJ,CAAS6D,KAAhB;UACAqH,MAAM,CAACC,MAAP,CAAcd,IAAd,EAAoB;YAAEC,UAAF;YAAcC,OAAd;YAAuBC;UAAvB,CAApB;UACA;QACD;;QAEDK,WAAW,CAAClE,GAAD,CAAX;MACD;;MAED,IAAIyD,SAAS,KAAK,IAAd,IAAsBpK,IAAI,KAAK,IAAnC,EAAyC;QACvC6E,WAAW,CAAC;UAAE7E,IAAF;UAAQ8E,UAAU,EAAE,IAApB;UAA0BG,SAAS,EAAE;QAArC,CAAD,CAAX;MACD;IACF;;IAED,SAASmG,SAAT,CAAoBC,CAApB,EAAuB;MACrB3I,kBAAkB;;MAElB,IACEa,QAAQ,CAACM,KAAT,KAAmB,IAAnB,IACGlB,OAAO,CAACkB,KAAR,KAAkB,IADrB,IAEGwH,CAAC,CAACC,MAFL,IAGG,OAAOD,CAAC,CAACC,MAAF,CAASC,OAAhB,KAA4B,UAJjC,EAKE;QACA,MAAM5E,GAAG,GAAG0E,CAAC,CAACC,MAAF,CAASC,OAAT,CAAiB,QAAjB,CAAZ,CADA,CAGA;QACA;;QACA,IAAI5E,GAAG,IAAIhE,OAAO,CAACkB,KAAR,CAAc2H,QAAd,CAAuB7E,GAAvB,MAAgC,IAA3C,EAAiD;UAC/CpD,QAAQ,CAACM,KAAT,GAAiB,IAAjB;QACD;MACF;IACF;;IAED,SAAS4H,UAAT,GAAuB;MACrBjJ,oBAAoB,CAAC,MAAM;QAAEe,QAAQ,CAACM,KAAT,GAAiB,KAAjB;MAAwB,CAAjC,EAAmC,EAAnC,CAApB;IACD;;IAED,SAAS6H,gBAAT,GAA6B;MAC3B,IAAIC,KAAK,CAACC,iBAAN,KAA4B,IAAhC,EAAsC;QACpCrJ,eAAe,CAAC4H,iBAAD,CAAf;MACD;IACF;;IAED,SAAS0B,WAAT,CAAsBC,MAAtB,EAA8B;MAC5BxI,OAAO,CAACyI,IAAR,CAAaD,MAAb;MAEA,MAAME,SAAS,GAAGhC,YAAY,EAA9B;;MAEA,IAAIgC,SAAS,CAAC9C,MAAV,GAAmB,CAAvB,EAA0B;QACxB,IAAIvF,YAAY,KAAK,KAAK,CAA1B,EAA6B;UAC3BA,YAAY,GAAGlF,KAAK,CAAC,MAAMyD,EAAE,CAACC,KAAH,CAASwI,MAAhB,EAAwBe,gBAAxB,CAApB;QACD;;QAEDA,gBAAgB;MACjB;IACF;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;IACI,SAASO,aAAT,CAAwBC,OAAxB,EAAiC;MAC/B5I,OAAO,CAAC6I,MAAR,CAAe7I,OAAO,CAACkG,OAAR,CAAgB0C,OAAhB,CAAf,EAAyC,CAAzC;;MAEA,IAAIvI,YAAY,KAAK,KAAK,CAA1B,EAA6B;QAC3B,MAAMqI,SAAS,GAAGhC,YAAY,EAA9B;;QAEA,IAAIgC,SAAS,CAAC9C,MAAV,KAAqB,CAAzB,EAA4B;UAC1BvF,YAAY;UACZA,YAAY,GAAG,KAAK,CAApB;QACD;;QAED+H,gBAAgB;MACjB;IACF;;IAED,MAAMC,KAAK,GAAG;MACZ9I,YADY;MAEZkB,QAFY;MAGZR,QAHY;MAKZsI,WALY;MAMZI,aANY;MAQZP,gBARY;MASZ7G,WATY;MAUZG,iBAVY;MAWZ2D,aAXY;MAaZiD,iBAAiB,EAAE;IAbP,CAAd;IAgBA7M,OAAO,CAACQ,OAAD,EAAUoM,KAAV,CAAP;IAEAhN,eAAe,CAAC,MAAM;MACpBqI,YAAY,CAACvD,YAAD,CAAZ;MACAE,YAAY,KAAK,KAAK,CAAtB,IAA2BA,YAAY,EAAvC;IACD,CAHc,CAAf;IAKA,IAAIyI,cAAc,GAAG,KAArB;IAEAvN,aAAa,CAAC,MAAM;MAClBuN,cAAc,GAAG,IAAjB;IACD,CAFY,CAAb;IAIAxN,WAAW,CAAC,MAAM;MAChBwN,cAAc,KAAK,IAAnB,IAA2BpH,iBAAiB,EAA5C;IACD,CAFU,CAAX;IAIA,OAAO,MAAM;MACX,MAAMqH,KAAK,GAAG,CACZ/N,CAAC,CAACW,eAAD,EAAkB;QAAEqN,QAAQ,EAAEjH;MAAZ,CAAlB,CADW,EAGZ/G,CAAC,CAAC,KAAD,EAAQ;QACPC,GAAG,EAAEqE,UADE;QAEP2J,KAAK,EAAEpI,UAAU,CAACN,KAFX;QAGP2I,QAAQ,EAAE5I;MAHH,CAAR,EAIEtE,KAAK,CAAC0C,KAAK,CAACzB,OAAP,CAJP,CAHW,CAAd;MAUA2C,aAAa,CAACW,KAAd,KAAwB,IAAxB,IAAgCwI,KAAK,CAACN,IAAN,CAC9BzN,CAAC,CAACU,KAAD,EAAQ;QACPuN,KAAK,EAAE,4DACFxJ,SAAS,CAACc,KAAV,KAAoB,IAApB,GAA2B,EAA3B,GAAgC,uBAD9B,CADA;QAGP7D,IAAI,EAAEC,KAAK,CAACkB,QAAN,IAAkBiB,EAAE,CAACqK,OAAH,CAAW3D,IAAX,CAAiB7I,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B,IAA1B,GAAiC,MAAlD,CAHjB;QAIP8M,WAAW,EAAEnE,aAJN;QAKPoE,mBAAmB,EAAEpE,aALd;QAMPqE,SAAS,EAAExE,cANJ;QAOPyE,YAAY,EAAEzE,cAPP;QAQP0E,UAAU,EAAE1E;MARL,CAAR,CAD6B,EAY9B9J,CAAC,CAACU,KAAD,EAAQ;QACPuN,KAAK,EAAE,6DACFvJ,UAAU,CAACa,KAAX,KAAqB,IAArB,GAA4B,EAA5B,GAAiC,uBAD/B,CADA;QAGP7D,IAAI,EAAEC,KAAK,CAACmB,SAAN,IAAmBgB,EAAE,CAACqK,OAAH,CAAW3D,IAAX,CAAiB7I,KAAK,CAACL,QAAN,KAAmB,IAAnB,GAA0B,MAA1B,GAAmC,OAApD,CAHlB;QAIP8M,WAAW,EAAEjE,WAJN;QAKPkE,mBAAmB,EAAElE,WALd;QAMPmE,SAAS,EAAExE,cANJ;QAOPyE,YAAY,EAAEzE,cAPP;QAQP0E,UAAU,EAAE1E;MARL,CAAR,CAZ6B,CAAhC;MAwBA,OAAO9J,CAAC,CAAC,KAAD,EAAQ;QACdC,GAAG,EAAEoE,OADS;QAEd4J,KAAK,EAAErI,OAAO,CAACL,KAFD;QAGdkJ,IAAI,EAAE,SAHQ;QAId3B,SAJc;QAKdK;MALc,CAAR,EAMLY,KANK,CAAR;IAOD,CA1CD;EA2CD;;AAtlB4B,CAAD,CAA9B"},"metadata":{},"sourceType":"module"}